name: CI/CD Release Pipeline

on:
  push:
    branches:
      - dev
      - main
  pull_request:
    branches:
      - dev
      - main

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_ACCOUNT_ID: ${{ github.event.inputs.environment == 'dev' && secrets.AWS_ACCOUNT_ID_DEV || github.event.inputs.environment == 'staging' && secrets.AWS_ACCOUNT_ID_STAGING  || secrets.AWS_ACCOUNT_ID_PROD }}
  AWS_REGION: ${{ github.event.inputs.region }}
  AWS_DOMAIN: artifacts
  AWS_REPO: Artifacts
  IMAGE: postgresql-server

jobs:
  ci:
    name: ci
    runs-on: ${{ vars.RUNNER }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Lint code
        run: echo "lint"

      - name: Test code
        run: echo "test"
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: "3.11"
    
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Docker image
        run: |
          docker build -t ${{ env.IMAGE }}:latest .
      
      - name: List Images
        run: |
          docker images
        
      - name: Save Docker image as artifact
        run: |
          docker save ${{ env.IMAGE }}:latest -o ${{ env.IMAGE }}.tar
    
      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.IMAGE }}
          path: ${{ env.IMAGE }}.tar

  cd:
    name: cd
    if: ${{ github.ref_name == 'dev' || github.ref_name == 'main'}}
    needs: ci
    runs-on: ${{ vars.RUNNER }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0
          ref: ${{ github.ref }}
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: "3.11"

      - name: Get commits since last tag
        id: get_commits
        run: |
          # Determine the last tag, if none found, assume initial version
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            # No previous tags, consider all history
            COMMITS=$(git log --pretty=format:"%s")
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s")
          fi
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Determine new version
        id: determine_version
        run: |
          MAJOR_PATTERN='BREAKING'
          MINOR_PATTERN='feat'
          PATCH_PATTERN='fix'
          
          COMMITS="${{ steps.get_commits.outputs.commits }}"
          
          BUMP_TYPE="patch" # default
          if echo "$COMMITS" | grep -Eq "$MAJOR_PATTERN"; then
            BUMP_TYPE="major"
          elif echo "$COMMITS" | grep -Eq "$MINOR_PATTERN"; then
            BUMP_TYPE="minor"
          fi

          echo "Bump type: $BUMP_TYPE"
          
          VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          VERSION_NUM=${VERSION#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
          
          if [ "$BUMP_TYPE" == "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$BUMP_TYPE" == "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          
          # If we're on dev, create a pre-release version (beta)
          if [ "${GITHUB_REF_NAME}" = "dev" ]; then
            PRE_RELEASE_VERSION="${NEW_VERSION}-beta.${GITHUB_RUN_NUMBER}"
            echo "pre_release_version=${PRE_RELEASE_VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Push tag
        if: ${{ github.ref_name == 'main' }}
        run: |
          NEW_VERSION="${{ steps.determine_version.outputs.new_version }}"
          git tag "v${NEW_VERSION}"
          git push origin "v${NEW_VERSION}"
  
      - name: Download Docker Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.IMAGE }}
          path: .
          
      - name: Tag Docker Image with Release Version
        run: |
          docker load -i ${{ env.IMAGE }}.tar

          if [ "${GITHUB_REF_NAME}" = "main" ]; then
            docker tag ${{ env.IMAGE }}:latest ghcr.io/${{ github.actor }}/${{ env.IMAGE }}:v${{ steps.determine_version.outputs.new_version }}
          else
            docker tag ${{ env.IMAGE }}:latest ghcr.io/${{ github.actor }}/${{ env.IMAGE }}:v${{ steps.determine_version.outputs.pre_release_version }}
          fi

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: List Images
        run: docker images

      - name: Push Docker image
        run: |
          if [ "${GITHUB_REF_NAME}" = "main" ]; then
            docker push ghcr.io/${{ github.actor }}/${{ env.IMAGE }}:v${{ steps.determine_version.outputs.new_version }}
          else
            docker push ghcr.io/${{ github.actor }}/${{ env.IMAGE }}:v${{ steps.determine_version.outputs.pre_release_version }}
          fi